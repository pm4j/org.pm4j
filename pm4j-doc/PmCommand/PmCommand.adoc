= PmCommand =
:author: TEBA Team
:doctype: book
:toc:
:lang: en
:encoding: iso-8859-1

== Purpose of the component ==

PmCommand models support UI logic for view components triggering actions. E.g. buttons, links or menu entries.

== Usage of PmCommand objects ==

=== Relevant classes and interfaces ===

==== Core interfaces and classes ====

* _PmCommand_ - external interface for views
* _PmCommandImpl_ - a basic command logic implementation

==== Specialized command classes ====

* _PmCommandDecorator_ - interface for command execution interceptors
* _PmCommandProxy_ - fix commands that may delegate requests to a registered executing command. +
  Example use case: A fix toolbars that delegating calls to actual context specific real commands.

== PmCommand usage ==

In this chapter we will describe how a framework user can add a new command element. An example for that will be the usage of a button command element.  

=== Adding a new PmCommand ===

To use a new command element you have to add the ui element (e.g. commandButton) into the xhtml file and corresponding PmCommand object into the related java implementation.

1. Java code:
[source]
public final PmCommand cmdSave = new PmCommandImpl(this);

1. View (e.g. JSF)
[source]
<pmtags:commandButton pm="#{pm.cmdSave}" />

=== Defining an action ===

To implement the necessary actions to execute you just have to override the _doItImpl()_ method.

[source]
@Override
protected void doItImpl() {
  // ... some UI logic code
}


// OBO: Den Validierungsblock würde ich weglassen. Die Doku sollte sich auf beforeDo und afterDo beschränken.
// die validate() Methode ist m.E. durchaus ein Löschkandidat.
=== Validation of a PM area ===

The validation of a command element is automatically called before executing the command. The default implementation of PMCommand 
triggers the validation of the parent element, whereat the parent is the first parent that implements the PmDataInput interface.
This means that the validation process validates the sub tree of this parent element, so that the attribute configuration 
(e.g. @PmAttrCfg(required = true)) and the implemented validation method of every element of the sub tree are executed. 
After validating the parent element the validation process checks if there are any error messages. 

If the developer wants to have a different kind of validation he just has to override the validate method of PmCommand.

[source] 
@Override
protected boolean validate() {
    // some specific validation
    ...
}

To implement some specific validation rules for an element of the subtree the developer just has override the validation method of that element (e.g. PmAttrString).

[source]
------------------------------------------------------------------------
@PmAttrCfg(required = true)
public final PmAttrString myAttribute = new PmAttrStringImpl(this) {

    @Override
    protected void validate(String value) throws PmValidationException {
        super.validate(value);

        // more validation actions
        ...
    }
};
------------------------------------------------------------------------

NOTE: Be careful: Do not forget to call the super implementation of validate. Otherwise you will get a completely independent validation implementation. 
This means that you will loose all inherited validation actions like checking configured annotations (e.g. @PmAttrCfg). 

=== Configuration of PmCommandCfg annotation ===

With the PmCommandCfg you have the possibility to change the default behaviour of the PmCommand object. This means that you can configure for example 
the behaviour before or after executing the command.

==== beforeDo ====

The _beforeDo_ paramter defines what should be done before executing the command logic, whereat the following actions are possible:

* VALIDATE: This call validates the entered data of the containing PmDataInput objects (see Validation of a PM area [HIER LINK SETZEN!]). The doItImpl method of the command 
will only be executed if the validation was successful.
* CLEAR: Clears all messages within the current PmConversation. Additionally entered string values that have failed to convert to the corresponding attribute value type 
will also be cleared. The doItImpl method of the command will be executed regardless if there are errors within the related PmConversation or not.
* DO_NOTHING: Does not care about existing (error-) messages and does not clear any of these messages before it gets executed.
* DEFAULT: The definition, defined in the project specific PmDefaults will be used. The default implementation is VALIDATE.

==== afterDo ====

The _afterDo_ parameter defines what should be done after executing the command logic, whereat the following actions are possible:

* RESET_VALUE_CHANGED_STATE: Resets the value change state of the pm that is used as validation root.
* CLEAR_CACHES: Clears the caches of all pm's along the path to the root pm. 
* DO_NOTHING: Does not executes any special operation in the after do method of the command.
* DEFAULT: The default logic is to execute CLEAR_CACHES and if VALIDATE is set for the beforeDo action also RESET_VALUE_CHANGED_STATE.

==== cmdKind ====

The various roles of a commands in toolbars and command menus are supported by a CmdKind enum indicator.  

The default value is COMMAND.

* COMMAND: Commands that are in general executeable. An executeable command may also have subcommands provided by getSubCommandList of PmCommand. 
This way an executeable command may also act as command group.
* GROUP: A pure organizational structure of commands.
* SEPARATOR: A separator between command sections of a command list.

// OBO: will be deprecated.
==== hideWhenNotEnabled ====

* If true, the command should be hidden when not applicable. The default value is false.

==== clearCaches ====

*  Defines the caches to clear within the element context of this command. The default value is an empty array, which means that there is nothing to clear.

=== Navigate to another view ===

//OBO: HotLinkCommandPm is not available in pm4j. - I just detected it, and it's a candidate for removal. - A view adapter should do what's defined there.

To navigate to another view you can use the HotLinkCommandPm. Here you have to override the getNaviLinkImpl to return a NaviLink object, 
that contains the information about the target to navigate to. Optional it is also possible to add some parameters.

[source]
------------------------------------------------------------------------
public final PmCommand cmdNavigateToFixTarget = new PmCommandImpl(this, new NaviLinkImpl("/page/someDialog.iface"));

public final PmCommand cmdNavigateToCalculatedTarget = new PmCommandImpl(this);

    @Override
    protected NaviLink getNaviLinkImpl() {
		String page = someCondition() ? "targetPage1" : "targetPage2";
		
        // Path to the requested component
        NaviLinkImpl naviLink = new NaviLinkImpl(page);
        
        naviLink.addParam("name", "value");
        // ... more parameter ...
        return naviLink;
    }
};

public final PmCommand cmdThatOnlySometimesNavigates = new PmCommandImpl(this);

    @Override
    protected void doItImpl() {
        // .. some logic
		if (verySpecialCondition()) {
		   setNaviLink(new NaviLinkImpl("specialConditionHandlingPage");
		}
    }
};

------------------------------------------------------------------------

// OBO: should be moved to the Globe specific hotlink docu.

You can read these parameter in the target object like this:

[source]
@Override
    protected void afterDialogInitialization() {
        String value = Jsf2Util.readRequestParameter("name");
		... more parameter ...
    }
}

=== Success message ===

After executing your action, it is possible to present the user a success message. This could happen via two different ways:

* By implementing a success message via PmMessageApi in the doItImpl method of your PmCmmand object.

[source]
------------------------------------------------------------------------
@Override
protected void doItImpl() throws Exception {
    ...
    PmMessageApi.addMessage(this, Severity.INFO, "message.key", value1, value2);
}
------------------------------------------------------------------------

Then you also have to add a message for your message key into the related resource file.
[source]
message.key={0} successfully done in {1}.

* By defining a string resource having the postfix _successInfo.
[source]
cmdDoSomething=Do Something
cmdDoSomething_successInfo=Something was successfully done.

Example:
  cmdDoSomething=Do Something
  cmdDoSomething_successInfo=Something was successfully done.


=== Testing commands ===

It quite easy to test the implemented functionality of a PmCommand object. To do so you have to create a test conversation for the view that contains your command, first (1).
Then you can test the implementation of the PMCommand by calling the doIt method (2). To check, if the execution of doIt was successful or not you can validate the CommandState 
of the PmCommand cmd, now. In our first test the execution should be successful, so the CommandState should be EXECUTED (3).

When calling the doIt method, it first validates the command like it is descriped in "Validation of a PM area" [HIER LINK SETZEN!]. So it is sometimes required to initialize all 
the attributes of the parent of your command to prevent a validation error, first (4). But if you want to check that the validation also works fine, you only have to call the doIt method 
without initializing the view attributes. Then you will not receive an EXECUTED command state, but a BEFORE_DO_RETURNED_FALSE command state (5). When getting such a validation error,
you are also able to check the content of the validation messages, so that you can verify that the validation works correct (6).

[source]
------------------------------------------------------------------------
public class MyFormPmTest {

	// OBO: Views and PMs are different concepts.
    private MyFormPm form = new MyFormPm();

	public void testSaveValidValues() {
		PmAssert.setValue(form.requiredAttr, "My Value");
		PmAssert.doIt(form.cmdSave);
    }
	
	public void testSaveWithoutRequiredValueShouldFail() {
		PmAssert.doIt(form.cmdSave, CommandState.FAILED);
		PmAssert.assertMessage(form, Severity.ERROR, "Please enter a valid value in 'required attr'");
    }
}
------------------------------------------------------------------------

== Implementation of PmCommand in pm4j ==

=== Class model ===

image:resources/PmCommand_Overview.png[]
